<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>建築經營協會慈善賭王Black Jack 大賽</title>
    <!-- 載入 Tailwind CSS --><script src="https://cdn.tailwindcss.com"></script>
    <!-- 載入 Noto Sans 字體 (用於中文和英文) --><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Noto+Sans+TC:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #f59e0b; /* Amber 500 */
            --secondary-color: #dc2626; /* Red 600 */
            --gold-start: #ffeb3b; /* Light Gold */
            --gold-end: #f59e0b;   /* Darker Gold (Amber) */
            --card-back-red: #ff8888; /* Light Red for card back */
        }
        body {
            font-family: 'Noto Sans TC', 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            /* 設置背景圖片 */
            background-image: url('https://i.imgur.com/ZzKd8Lt.jpeg');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            min-height: 100vh;
        }
        #gameCanvas {
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.5), 0 4px 6px -2px rgba(0, 0, 0, 0.25);
            border: 4px solid var(--primary-color);
            background-color: rgba(30, 64, 46, 0.9); /* Dark Green Table */
        }
        
        /* --- 按鈕樣式升級：保留互動效果，移除背景以便圖片顯示 --- */
        .control-btn {
            /* 保持響應式 Padding，但讓圖片填滿 */
            @apply px-1 py-1 rounded-xl font-bold transition duration-300 ease-in-out shadow-lg transform hover:scale-105 border-0;
            /* 自訂陰影 */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            /* 將背景設為透明或白色，讓圖片顯示 */
            background-color: transparent !important; 
            color: transparent !important; /* 隱藏 fallback 文字 */
            line-height: 0; /* 移除行高，讓圖片更好地居中 */
        }
        /* 統計重置按鈕仍使用原始的金色漸層 */
        #resetStatsBtn {
            background: linear-gradient(180deg, var(--gold-start) 0%, var(--gold-end) 100%) !important;
            color: #1a202c !important;
            line-height: normal; /* 恢復行高 */
            @apply px-3 py-1 text-xs md:text-sm;
        }
        /* 按鈕內的圖片樣式 */
        .button-img {
            /* 確保圖片填滿按鈕且不變形 */
            @apply w-full h-full object-contain p-0;
        }
    </style>
</head>
<body class="p-1 md:p-6 flex flex-col items-center">

    <!-- 標題與 Logo 區塊: 移除 max-w-lg 限制，使用 w-full --><div class="w-full mx-auto mb-3 p-3 rounded-xl bg-gray-900/80 shadow-2xl flex items-center space-x-4">
        <img id="logoImg" src="https://i.imgur.com/sDO3tAh.png" alt="Logo" class="w-16 h-auto">
        <div class="text-left">
            <h1 class="text-lg md:text-xl font-black text-white leading-snug">建築經營協會慈善賭王<br>Black Jack 大賽</h1>
        </div>
    </div>

    <!-- 遊戲統計區: 移除 max-w-lg 限制，使用 w-full --><div class="w-full mx-auto mb-3 p-3 bg-gray-800/90 rounded-xl shadow-xl flex justify-around text-white text-sm md:text-base">
        <div class="text-center">
            <div class="font-bold text-gray-400">勝場 (Wins)</div>
            <div id="statWins" class="text-green-400 text-xl font-mono">0</div>
        </div>
        <div class="text-center">
            <div class="font-bold text-gray-400">敗場 (Losses)</div>
            <div id="statLosses" class="text-red-400 text-xl font-mono">0</div>
        </div>
        <div class="text-center">
            <div class="font-bold text-gray-400">勝率 (Rate)</div>
            <div id="statRate" class="text-yellow-400 text-xl font-mono">0.00%</div>
        </div>
        <button id="resetStatsBtn" class="control-btn bg-blue-500 text-white px-3 py-1 self-center text-xs md:text-sm">重置統計</button>
    </div>

    <!-- Canvas 遊戲區: 移除 max-w-lg 限制，並將長寬比調整為 5/4 (更接近正方形，適合手機) --><div class="w-full aspect-[5/4] mx-auto relative rounded-xl overflow-hidden">
        <canvas id="gameCanvas" class="w-full h-full"></canvas>
    </div>

    <!-- 遊戲控制按鈕區: 移除 max-w-lg 限制，使用 w-full --><div id="controls" class="w-full mx-auto mt-3 mb-3 flex justify-center space-x-4">
        <!-- 初始按鈕將在 JS 中設定為圖片 --><button id="hitBtn" class="control-btn w-1/3">要牌 (Hit)</button>
        <button id="standBtn" class="control-btn w-1/3">停牌 (Stand)</button>
    </div>

    <script>
        // 全局變量
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statWins = document.getElementById('statWins');
        const statLosses = document.getElementById('statLosses');
        const statRate = document.getElementById('statRate');
        const controlsDiv = document.getElementById('controls');
        
        // 遊戲狀態
        let deck = [];
        let playerHand = [];
        let dealerHand = [];
        let gameActive = false;
        let gameStatus = 'initial'; // 'initial', 'playerTurn', 'dealerTurn', 'end'
        
        // 統計數據
        let stats = { wins: 0, losses: 0 };

        // 卡牌圖片 URLs (使用 placeholder 作為通用卡片和背面)
        const customCardImages = {
            J: 'https://i.imgur.com/v16ILID.png',
            Q: 'https://i.imgur.com/5d46u7D.png',
            K: 'https://i.imgur.com/MolqeHf.png',
            BACK: 'https://placehold.co/100x150/606060/FFFFFF?text=Card+Back', // 灰色卡背
            WELCOME: 'https://i.imgur.com/Y9znMk1.png', // 歡迎圖片
            
            // 新增的按鈕圖片
            HIT_BTN: 'https://i.imgur.com/wBUAsyk.png', 
            STAND_BTN: 'https://i.imgur.com/778ZjRH.png', 
            NEW_BTN: 'https://i.imgur.com/yudolIL.png' 
        };
        
        // 圖片資源載入
        const images = {};
        const cardValues = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
        const cardSuits = ['♥', '♦', '♠', '♣'];
        
        // totalImages 現在包含 J, Q, K, WELCOME, HIT_BTN, STAND_BTN, NEW_BTN (共 7 張)
        let imagesLoaded = 0;
        const totalImages = 7; 
        
        // --- 1. 圖片載入函數 ---
        function loadImages() {
            // 載入所有圖片，包括撲克牌圖片和按鈕圖片
            const keys = ['J', 'Q', 'K', 'WELCOME', 'HIT_BTN', 'STAND_BTN', 'NEW_BTN']; 
            keys.forEach(key => {
                images[key] = new Image();
                images[key].onload = () => {
                    imagesLoaded++;
                    if (imagesLoaded === totalImages) {
                        console.log('所有圖片載入完成。');
                        loadStats();
                        resizeCanvas();
                        drawGame();
                    }
                };
                images[key].onerror = () => {
                    console.error(`圖片載入失敗: ${key} (${customCardImages[key]})`);
                    images[key] = null; // 失敗時設定為 null，以便回退
                    imagesLoaded++;
                    if (imagesLoaded === totalImages) {
                        loadStats();
                        resizeCanvas();
                        drawGame();
                    }
                };
                images[key].src = customCardImages[key];
            });
        }
        
        // --- 2. 統計數據 (localStorage) 管理 ---
        function loadStats() {
            try {
                const storedStats = localStorage.getItem('blackjackStats');
                if (storedStats) {
                    stats = JSON.parse(storedStats);
                }
            } catch (e) {
                console.error("無法從 localStorage 讀取統計數據", e);
                stats = { wins: 0, losses: 0 };
            }
            updateStatsDisplay();
        }

        function saveStats() {
            try {
                localStorage.setItem('blackjackStats', JSON.stringify(stats));
            } catch (e) {
                console.error("無法儲存統計數據到 localStorage", e);
            }
            updateStatsDisplay();
        }

        function updateStatsDisplay() {
            statWins.textContent = stats.wins;
            statLosses.textContent = stats.losses;
            const totalGames = stats.wins + stats.losses;
            const rate = totalGames > 0 ? (stats.wins / totalGames) * 100 : 0;
            statRate.textContent = `${rate.toFixed(2)}%`;
        }
        
        function resetStats() {
            stats = { wins: 0, losses: 0 };
            saveStats();
            // 如果遊戲在結束狀態，重新繪製以更新統計數字
            if (gameStatus === 'end' || gameStatus === 'initial') {
                drawGame();
            }
        }

        // --- 3. 核心遊戲邏輯 (不變) ---
        
        // 產生一副新牌組並洗牌 (Fisher-Yates 演算法)
        function createAndShuffleDeck() {
            deck = [];
            for (let suit of cardSuits) {
                for (let value of cardValues) {
                    deck.push({ value, suit });
                }
            }
            // 洗牌
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
            return deck;
        }

        function dealCard(hand) {
            if (deck.length > 0) {
                hand.push(deck.pop());
            }
        }

        /**
         * 計算手牌總分 (自動處理 A 點數 1/11)
         */
        function calculateScore(hand, isDealerHidden = false) {
            let score = 0;
            let aceCount = 0;
            const cardsToCount = isDealerHidden ? hand.slice(1) : hand;

            for (let card of cardsToCount) {
                if (card.value === 'A') {
                    aceCount++;
                    score += 11;
                } else if (['K', 'Q', 'J'].includes(card.value)) {
                    score += 10;
                } else {
                    score += parseInt(card.value);
                }
            }

            // 調整 A 的點數 (11 -> 1) 直到總分不高於 21
            while (score > 21 && aceCount > 0) {
                score -= 10; // 11 變成 1
                aceCount--;
            }

            return score;
        }

        // --- 4. 遊戲流程控制 ---
        
        /**
         * 輔助函數: 生成帶圖片的按鈕 HTML 內容
         */
        function getButtonHtml(key, fallbackText) {
            const img = images[key];
            if (img && img.complete) {
                // 使用圖片作為按鈕內容
                return `<img src="${img.src}" alt="${fallbackText}" class="button-img">`;
            }
            // 圖片未載入或失敗時，回退到文字
            return fallbackText;
        }

        function startGame() {
            if (gameActive) return;

            deck = createAndShuffleDeck();
            playerHand = [];
            dealerHand = [];
            gameStatus = 'playerTurn';
            gameActive = true;
            
            // 使用圖片按鈕 (保留 control-btn class 的互動效果)
            controlsDiv.innerHTML = `
                <button id="hitBtn" class="control-btn w-1/3">${getButtonHtml('HIT_BTN', '要牌 (Hit)')}</button>
                <button id="standBtn" class="control-btn w-1/3">${getButtonHtml('STAND_BTN', '停牌 (Stand)')}</button>
            `;
            document.getElementById('hitBtn').onclick = hit;
            document.getElementById('standBtn').onclick = stand;

            // 發初始兩張牌
            dealCard(playerHand);
            dealCard(dealerHand);
            dealCard(playerHand);
            dealCard(dealerHand);

            drawGame();
            checkBlackjack();
        }
        
        function hit() {
            if (gameStatus !== 'playerTurn') return;

            dealCard(playerHand);
            drawGame();
            
            const score = calculateScore(playerHand);
            if (score > 21) {
                endGame('bust');
            } else if (score === 21) {
                // 玩家拿到 21 點，自動停牌，換莊家回合
                stand();
            }
        }
        
        function stand() {
            if (gameStatus !== 'playerTurn') return;

            gameStatus = 'dealerTurn';
            // 立即顯示莊家底牌
            drawGame(); 
            
            // 莊家回合延遲處理
            setTimeout(dealerPlay, 1000);
        }

        function dealerPlay() {
            let dealerScore = calculateScore(dealerHand);
            
            // 莊家規則: 16 點或以下必須要牌；17 點或以上必須停牌
            if (dealerScore < 17) {
                dealCard(dealerHand);
                drawGame();
                dealerScore = calculateScore(dealerHand);
                
                if (dealerScore > 21) {
                    endGame('dealerBust');
                } else {
                    // 繼續下一次檢查
                    setTimeout(dealerPlay, 1000); 
                }
            } else {
                // 莊家停牌 (>= 17)
                endGame('finalCheck');
            }
        }
        
        function checkBlackjack() {
            const pScore = calculateScore(playerHand);
            const dScore = calculateScore(dealerHand);

            if (pScore === 21 && dScore === 21) {
                endGame('push');
            } else if (pScore === 21) {
                endGame('playerBlackjack');
            } else if (dScore === 21) {
                endGame('dealerBlackjack');
            }
        }

        function endGame(reason) {
            gameActive = false;
            gameStatus = 'end';
            
            let message = '';
            let win = false;
            const pScore = calculateScore(playerHand);
            const dScore = calculateScore(dealerHand);

            switch (reason) {
                case 'bust': // 玩家爆牌
                    message = `💥 玩家爆牌! (${pScore}) 莊家獲勝!`;
                    stats.losses++;
                    break;
                case 'dealerBust': // 莊家爆牌
                    message = `莊家爆牌! (${dScore}) 🎉 玩家獲勝!`;
                    stats.wins++;
                    win = true;
                    break;
                case 'playerBlackjack': // 玩家 Blackjack
                    message = `♠️♥️ 玩家 Blackjack! 玩家獲勝!`;
                    stats.wins++;
                    win = true;
                    break;
                case 'dealerBlackjack': // 莊家 Blackjack
                    message = `♦️♣️ 莊家 Blackjack! 莊家獲勝!`;
                    stats.losses++;
                    break;
                case 'push': // 平手 (Blackjack 或點數相同)
                    message = `🤝 平手 (Push)! 不計勝敗。`;
                    break;
                case 'finalCheck': // 莊家停牌，進行最終點數比較
                    if (pScore > dScore) {
                        message = `玩家 ${pScore} 點 > 莊家 ${dScore} 點! 🎉 玩家獲勝!`;
                        stats.wins++;
                        win = true;
                    } else if (dScore > pScore) {
                        message = `莊家 ${dScore} 點 > 玩家 ${pScore} 點! 莊家獲勝!`;
                        stats.losses++;
                    } else {
                        message = `🤝 平手 (Push)! ${pScore} 點。不計勝敗。`;
                    }
                    break;
                default:
                    message = '遊戲結束。';
            }
            
            saveStats();
            drawGame(message); // 帶上最終訊息繪製一次
            
            // 動態顯示「再來一局」圖片按鈕 (取代控制區)
            // 寬度統一為 w-1/3
            controlsDiv.innerHTML = `<button id="newGameBtn" class="control-btn w-1/3">${getButtonHtml('NEW_BTN', '再來一局 (New Game)')}</button>`;
            document.getElementById('newGameBtn').onclick = startGame;
        }


        // --- 5. Canvas 繪圖與 RWD (不變) ---

        // 卡片大小 (相對於 Canvas 寬度) 
        const CARD_WIDTH_RATIO = 0.20; 
        const CARD_HEIGHT_RATIO = 0.33; 

        function resizeCanvas() {
            const container = canvas.parentElement;
            // 設置 canvas 的內部解析度，使其與顯示尺寸匹配，避免模糊
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            drawGame();
        }

        /**
         * 繪製圓角矩形 (用於卡片背景)
         */
        function roundRect(x, y, w, h, radius) {
            const r = radius || 5;
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.arcTo(x + w, y, x + w, y + r, r);
            ctx.lineTo(x + w, y + h - r);
            ctx.arcTo(x + w, y + h, x + w - r, y + h, r);
            ctx.lineTo(x + r, y + h);
            ctx.arcTo(x, y + h, x, y + h - r, r);
            ctx.lineTo(x, y + r);
            ctx.arcTo(x, y, x + r, y, r);
            ctx.closePath();
        }

        /**
         * 繪製單張卡片 (包含新的卡背設計)
         */
        function drawCard(card, x, y, w, h, isHidden) {
            const radius = w * 0.1;
            
            // 繪製卡片邊緣
            roundRect(x, y, w, h, radius);
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 2;
            ctx.stroke();

            if (isHidden) {
                // *** 繪製卡背 (淺紅色底配上白色菱格條紋) ***
                ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--card-back-red') || '#ff8888';
                ctx.fill();

                ctx.strokeStyle = 'white';
                ctx.lineWidth = w * 0.05;
                
                ctx.save();
                ctx.clip(); // 限制繪圖區域在圓角矩形內
                
                const gridSize = w * 0.25; // 菱格大小
                
                // 變換原點並旋轉 45 度
                ctx.translate(x + w / 2, y + h / 2);
                ctx.rotate(Math.PI / 4); 
                ctx.translate(-(x + w / 2), -(y + h / 2));
                
                // 繪製線條 (覆蓋整個區域)
                for (let i = x - w; i < x + 2 * w; i += gridSize) {
                    // 垂直線 (旋轉後變斜線)
                    ctx.beginPath();
                    ctx.moveTo(i, y - w);
                    ctx.lineTo(i, y + h + w);
                    ctx.stroke();

                    // 水平線 (旋轉後變斜線)
                    ctx.beginPath();
                    ctx.moveTo(x - w, i);
                    ctx.lineTo(x + h + w, i);
                    ctx.stroke();
                }

                ctx.restore(); // 恢復剪裁區和變換
                
            } else {
                // 繪製卡片正面
                ctx.fillStyle = 'white';
                ctx.fill();

                const isRed = (card.suit === '♥' || card.suit === '♦');
                ctx.fillStyle = isRed ? '#dc2626' : '#111827';
                
                // 嘗試繪製自訂圖片 (J, Q, K)
                if (images[card.value]) {
                    // 繪製圖片
                    ctx.drawImage(images[card.value], x, y, w, h);
                    
                    // 繪製左上角小字和花色
                    ctx.font = `${w * 0.18}px 'Noto Sans TC', sans-serif`;
                    ctx.textAlign = 'left';
                    ctx.fillText(card.value, x + w * 0.05, y + h * 0.15);
                    ctx.fillText(card.suit, x + w * 0.05, y + h * 0.30);
                    
                } else {
                    // *** 繪製普通卡片 (左上角花色，中間數字) ***
                    
                    // 左上角花色
                    ctx.font = `${w * 0.25}px 'Noto Sans TC', sans-serif`;
                    ctx.textAlign = 'left';
                    ctx.fillText(card.suit, x + w * 0.08, y + h * 0.20); 

                    // 中間數字
                    ctx.font = `${w * 0.6}px 'Noto Sans TC', sans-serif`; // 字體加大
                    ctx.textAlign = 'center';
                    // 根據字體大小調整垂直位置
                    ctx.fillText(card.value, x + w / 2, y + h / 2 + (w * 0.6) / 3 * 0.8);
                    
                    // 右下角花色
                    ctx.textAlign = 'right';
                    ctx.font = `${w * 0.25}px 'Noto Sans TC', sans-serif`;
                    ctx.fillText(card.suit, x + w * 0.92, y + h * 0.85); 
                }
            }
        }
        
        /**
         * 主繪圖函數
         * @param {string} finalMessage - 遊戲結束時顯示的訊息
         */
        function drawGame(finalMessage = null) {
            const cw = canvas.width;
            const ch = canvas.height;
            const cardW = cw * CARD_WIDTH_RATIO;
            const cardH = ch * CARD_HEIGHT_RATIO;
            const padding = cw * 0.02;

            // 1. 清除畫布
            ctx.clearRect(0, 0, cw, ch);
            
            // 2. 繪製標題/分數區 (調整位置以騰出卡牌空間)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.font = `${cw * 0.045}px 'Noto Sans TC', sans-serif`;
            ctx.textAlign = 'center';
            
            // 莊家區 (Dealer) - 向上移動
            const dealerScore = calculateScore(dealerHand, gameStatus !== 'end');
            const dealerScoreText = gameStatus !== 'end' ? '??' : dealerScore;
            ctx.fillText(`莊家 (Dealer): ${dealerScoreText} 點`, cw / 2, ch * 0.08); 
            
            // 玩家區 (Player) - 向下移動
            const playerScore = calculateScore(playerHand, false);
            ctx.fillText(`玩家 (Player): ${playerScore} 點`, cw / 2, ch * 0.95); // 移到更底部

            // 3. 繪製莊家的牌
            // 調整起始 X 座標，使牌組居中
            const dealerStart_x = cw / 2 - ((dealerHand.length * cardW) + (dealerHand.length - 1) * padding) / 2;
            dealerHand.forEach((card, i) => {
                const isHidden = (i === 0 && gameStatus !== 'end');
                drawCard(
                    card, 
                    dealerStart_x + i * (cardW + padding), 
                    ch * 0.13, // 稍微向上移動
                    cardW, 
                    cardH, 
                    isHidden
                );
            });

            // 4. 繪製玩家的牌
            // 調整起始 X 座標，使牌組居中
            const playerStart_x = cw / 2 - ((playerHand.length * cardW) + (playerHand.length - 1) * padding) / 2;
            playerHand.forEach((card, i) => {
                drawCard(
                    card, 
                    playerStart_x + i * (cardW + padding), 
                    ch * 0.54, // 向上移動，為更大的卡片和底部分數騰出空間
                    cardW, 
                    cardH, 
                    false
                );
            });

            // 5. 繪製遊戲狀態訊息
            if (finalMessage) {
                // 灰色背景 (高度縮小，防止與卡片過度重疊)
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                // 調整黑框位置：從 ch * 0.38 開始，高度為 ch * 0.24
                roundRect(cw * 0.1, ch * 0.38, cw * 0.8, ch * 0.24, 10); 
                ctx.fill();

                // 訊息文字 (垂直居中在黑框內)
                ctx.fillStyle = '#FFF';
                ctx.font = `${cw * 0.05}px 'Noto Sans TC', sans-serif`;
                ctx.textAlign = 'center';
                // 垂直位置 = 框起始位置 + 框高度/2 (即 ch * 0.38 + ch * 0.12)
                ctx.fillText(finalMessage, cw / 2, ch * 0.50); 
                
                // 動態顯示「再來一局」圖片按鈕 (取代控制區)
                // 寬度統一為 w-1/3
                controlsDiv.innerHTML = `<button id="newGameBtn" class="control-btn w-1/3">${getButtonHtml('NEW_BTN', '再來一局 (New Game)')}</button>`;
                document.getElementById('newGameBtn').onclick = startGame;

            } else if (gameStatus === 'initial') {
                // 初始/等待狀態：繪製歡迎圖片
                if (images['WELCOME']) {
                    ctx.drawImage(images['WELCOME'], 0, 0, cw, ch);
                } else {
                    // 如果圖片載入失敗，則回退到文字顯示
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    roundRect(cw * 0.1, ch * 0.35, cw * 0.8, ch * 0.3, 10);
                    ctx.fill();

                    ctx.fillStyle = 'white';
                    ctx.font = `${cw * 0.06}px 'Noto Sans TC', sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText('準備開始遊戲', cw / 2, ch * 0.45);
                    ctx.font = `${cw * 0.04}px 'Noto Sans TC', sans-serif`;
                    ctx.fillText('點擊下方按鈕進行發牌', cw / 2, ch * 0.55);
                }

                // 初始狀態下，控制按鈕應該只有 Start/New Game - 使用圖片按鈕
                // 寬度統一為 w-1/3
                 controlsDiv.innerHTML = `<button id="newGameBtn" class="control-btn w-1/3">${getButtonHtml('NEW_BTN', '開始遊戲 (Start Game)')}</button>`;
                document.getElementById('newGameBtn').onclick = startGame;
            } else if (gameStatus === 'playerTurn') {
                 // 確保控制按鈕為 Hit/Stand - 使用圖片按鈕
                 if (!document.getElementById('hitBtn') || !document.getElementById('standBtn')) {
                    controlsDiv.innerHTML = `
                        <button id="hitBtn" class="control-btn w-1/3">${getButtonHtml('HIT_BTN', '要牌 (Hit)')}</button>
                        <button id="standBtn" class="control-btn w-1/3">${getButtonHtml('STAND_BTN', '停牌 (Stand)')}</button>
                    `;
                    document.getElementById('hitBtn').onclick = hit;
                    document.getElementById('standBtn').onclick = stand;
                 }
            }
        }


        // --- 6. 事件監聽器 ---
        
        // 頁面加載完成後初始化
        window.onload = function() {
            loadImages();
            // 在 Canvas 容器上監聽點擊事件，如果遊戲結束，點擊畫布中央的按鈕
            canvas.addEventListener('click', (event) => {
                if (gameStatus === 'end' || gameStatus === 'initial') {
                    // 模擬點擊中央的 New Game 按鈕
                    const newGameBtn = document.getElementById('newGameBtn');
                    if (newGameBtn) {
                        newGameBtn.click();
                    }
                }
            });
        };

        // RWD 處理：視窗大小改變時重設 Canvas 尺寸
        window.addEventListener('resize', resizeCanvas);

        // 初始設定控制按鈕事件 (這些會在 loadImages 結束後被覆蓋，但為了防止初期錯誤而保留)
        document.getElementById('hitBtn').onclick = hit;
        document.getElementById('standBtn').onclick = stand;
        document.getElementById('resetStatsBtn').onclick = resetStats;
    </script>
</body>
</html>

